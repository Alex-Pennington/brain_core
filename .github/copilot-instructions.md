# Paul Brain Modem Core - AI Coding Instructions

## Project Overview

This is a **MIL-STD-188-110A modem implementation** wrapped as a headless TCP server. The original modem core (`m188110a/`) was written by Paul Brain; the TCP wrapper (`src/main.cpp`) is by Phoenix Nest LLC for automated testing without audio hardware.

**Purpose**: Enable fair comparison testing between this modem and Phoenix Nest's implementation using identical TCP interfaces and PCM file formats.

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                  brain_modem_server                     │
├─────────────────────────────────────────────────────────┤
│  Control Port (3999)  │  Data Port (3998)               │
│  ASCII commands       │  Binary TX/RX data              │
├─────────────────────────────────────────────────────────┤
│               src/main.cpp (TCP Wrapper)                │
│  - Socket handling, command parsing, PCM file I/O      │
│  - Global modem instance: g_modem (Cm110s class)       │
├─────────────────────────────────────────────────────────┤
│               m188110a/ (Paul Brain Core)               │
│  Cm110s.h    - Main modem class, Mode enum, callbacks  │
│  txm110a.cpp - TX modulation chain                     │
│  rxm110a.cpp - RX demodulation, DCD, sync              │
│  eq110a.cpp  - Adaptive equalizer (LMS)                │
│  de110a.cpp  - Deinterleaver, Viterbi decoder          │
│  in110a.cpp  - Interleaver                             │
│  v110a.cpp   - Viterbi encoder/decoder                 │
│  g110a.cpp   - Symbol generation tables                │
│  ptx110a.cpp - Preamble generation                     │
│  t110a.cpp   - TX filter, interpolation                │
└─────────────────────────────────────────────────────────┘
```

---

## Development Workflow

### Git Branching Strategy

```
master (main)          ← All development happens here (draft state)
    │
    ├── push           → Triggers CI build, creates draft artifacts
    │
    └── git tag vX.Y.Z → Triggers release workflow, publishes to GitHub Releases
```

- **master branch**: Active development, all commits here
- **Tags (vX.Y.Z)**: Create releases - pushing a tag triggers the release workflow
- **No feature branches required**: Simple single-branch workflow for this project

### Release Types

| Type | Trigger | Version Format | Notes |
|------|---------|----------------|-------|
| **Dev Build** | Local `.\build.ps1` | `v1.0.1-local-abc1234` | For local testing only |
| **CI Build** | Push to master | N/A (no release) | Validates build works |
| **Tagged Release** | `git tag vX.Y.Z` | `vX.Y.Z-build.N-abc1234` | Published to GitHub Releases |

### Preferred Workflow

```bash
# 1. Make changes with conventional commits
git add -A
git commit -m "feat: add new feature"     # or fix:, docs:, refactor:, etc.

# 2. Push to master (validates CI build)
git push

# 3. When ready to release, create and push a tag
git tag -a v1.0.2 -m "Release description"
git push origin v1.0.2

# 4. GitHub Actions automatically:
#    - Builds with version string injected
#    - Creates attested artifacts
#    - Publishes GitHub Release
```

### Conventional Commit Types
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation changes
- `refactor:` - Code refactoring
- `test:` - Adding/updating tests
- `chore:` - Maintenance tasks

---

## Version System

### Version Format
```
v1.0.1-build.6-abc1234
│ │ │   │    │  └── Short commit SHA (7 chars)
│ │ │   │    └───── Build number (GitHub Actions run number)
│ │ │   └────────── Build indicator
│ │ └────────────── Patch version
│ └──────────────── Minor version
└────────────────── Major version
```

### Version Injection

Version strings are injected at compile time via `src/version.h`:

```cpp
// src/version.h (auto-generated by build scripts)
#ifndef VERSION_H
#define VERSION_H
#define VERSION_STRING "v1.0.1-build.6-abc1234"
#endif
```

**How it works:**
1. `build.ps1` (local) generates `src/version.h` with git commit info
2. GitHub Actions workflow generates version header with build number + commit
3. `src/main.cpp` includes `version.h` and uses `VERSION_STRING` macro

```cpp
// In src/main.cpp
#if __has_include("version.h")
#include "version.h"
#endif
#ifndef VERSION_STRING
#define VERSION_STRING "v1.0.1-dev"  // Fallback
#endif
```

### Version Bump Guidance

When releasing a new version, update these locations:

| File | What to Update |
|------|----------------|
| `.github/workflows/release.yml` | Default version in `workflow_dispatch.inputs.version` |
| `build.ps1` | `$localVersion` base version string |
| `src/main.cpp` | Fallback `VERSION_STRING` define |

**Semantic Versioning:**
- **Major (X.0.0)**: Breaking API changes
- **Minor (0.X.0)**: New features, backward compatible
- **Patch (0.0.X)**: Bug fixes, backward compatible

---

## Build System

### Local Build (Windows)

```powershell
.\build.ps1
```

Produces: `brain_modem_server.exe` with version `v1.0.1-local-<commit>`

### Local Build (Linux/macOS)

```bash
./build.sh
```

### CI/Release Build

Triggered by pushing a tag:
```bash
git tag -a v1.0.2 -m "Description"
git push origin v1.0.2
```

### Artifact Naming

| Platform | Executable | Archive |
|----------|------------|---------|
| Windows | `brain_modem_server_v1.0.2-build7-abc1234.exe` | `brain_modem_server_v1.0.2-build7-abc1234.zip` |

Archive contents:
```
brain_modem_server_v1.0.2-build7-abc1234.zip
├── brain_modem_server.exe
├── README.md
└── tx_pcm_out/        (empty directory for PCM output)
```

---

## Artifact Attestation

All release builds are signed with GitHub Artifact Attestation for supply chain security.

### Verify a Release

```bash
# Verify executable
gh attestation verify brain_modem_server_v1.0.2-build7-abc1234.exe --owner Alex-Pennington

# Verify ZIP archive
gh attestation verify brain_modem_server_v1.0.2-build7-abc1234.zip --owner Alex-Pennington
```

### What Attestation Proves
- The artifact was built by GitHub Actions
- The artifact was built from this repository
- The artifact was built from a specific commit
- The build process was not tampered with

---

## Build & Run

```powershell
# Windows (MinGW g++ required, C++17)
.\build.ps1

# Linux/macOS
./build.sh

# Run server
.\brain_modem_server.exe   # Windows
./brain_modem_server       # Linux
```

**Key defines**: `-D_USE_MATH_DEFINES -DWIN32` (Windows) or just `-D_USE_MATH_DEFINES` (Linux)

## Data Flow

1. **TX**: Data port → `g_tx_buffer` → `CMD:SENDBUFFER` → `Cm110s::tx_sync_frame_eom()` → PCM samples → `tx_pcm_out/*.pcm`
2. **RX**: `CMD:RXAUDIOINJECT:<file>` → `Cm110s::rx_process_block()` → `rx_byte_callback()` → `g_rx_buffer` → Data port

## Critical Patterns

### Thread Safety
All modem operations use `g_modem_mutex`. RX buffer uses separate `g_rx_mutex`. Follow this pattern:
```cpp
std::lock_guard<std::mutex> lock(g_modem_mutex);
g_modem.tx_set_mode(mode);
```

### Mode Enumeration
Modes are `MxxxS` (short interleave) or `MxxxL` (long interleave). Use `string_to_mode()` and `mode_to_status_string()` for conversions. The `Mode` enum is in `Cm110s.h`.

### PCM Format
- Sample rate: 48kHz (server) internally resampled to 9600Hz (modem core)
- Format: 16-bit signed PCM, little-endian, mono
- Output directory: `./tx_pcm_out/`

### Command Protocol
Commands are `CMD:<verb>` or `CMD:QUERY:<item>`. Responses are single-line ASCII. Always handle via `handle_command()` in main.cpp.

## Modem Core Notes

- **Do not modify** `m188110a/*.cpp` files unless fixing bugs - this is Paul Brain's original code
- `platform_compat.h` provides Windows/Linux compatibility shims (Sleep, sprintf_s, gmtime_s)
- Modem internal sample rate is 9600 Hz (`M1_SAMPLE_RATE`), carrier frequency 1800 Hz (`M1_CENTER_FREQUENCY`)
- Soundblock size is configurable via `tx_set_soundblock_size()` (default 1024 samples)

## Testing

```bash
# Start server, then run test client
python test_client.py
```

The test client demonstrates the command/response protocol. PCM files appear in `tx_pcm_out/` for analysis.

## Adding New Commands

1. Add case in `handle_command()` function in `src/main.cpp`
2. Follow existing pattern: parse command, acquire mutex if touching modem, call modem API, send response
3. Prefix responses with `OK:`, `ERROR:`, or appropriate status prefix
